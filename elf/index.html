<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The `elf` crate provides a pure-safe-rust interface for reading ELF object files."><title>elf - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-9ee3a5e31a2afa3e.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="elf" data-themes="" data-resource-suffix="" data-rustdoc-version="1.75.0-nightly (31bc7e2c4 2023-10-30)" data-channel="nightly" data-search-js="search-8fbf244ebcf71464.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-9dd44ab47b99a0fb.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../elf/index.html">elf</a><span class="version">0.7.2</span></h2></div><div class="sidebar-elems"><ul class="block">
            <li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‚ÄòS‚Äô to search, ‚Äò?‚Äô for more options‚Ä¶" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">elf</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/elf/lib.rs.html#1-161">source</a> ¬∑ <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The <code>elf</code> crate provides a pure-safe-rust interface for reading ELF object files.</p>
<h2 id="capabilities"><a href="#capabilities">Capabilities</a></h2><h4 id="-works-in-no_std-environments-"><a href="#-works-in-no_std-environments-">‚ú® Works in <code>no_std</code> environments ‚ú®</a></h4>
<p>This crate provides an elf parsing interface which does not allocate or use any std
features, so it can be used in <code>no_std</code> environments such as kernels and bootloaders.
The no_std variant merely disables the additional stream-oriented <code>std:: Read + Seek</code> interface.
All core parsing functionality is the same!</p>
<h4 id="-endian-aware-"><a href="#-endian-aware-">‚ú® Endian-aware ‚ú®</a></h4>
<p>This crate handles translating between file and host endianness when
parsing the ELF contents and provides four endian parsing implementations
optimized to support the different common use-cases for an ELF parsing library.
Parsing is generic across the specifications and each trait impl represents a
specification that encapsulates an interface for parsing integers from some
set of allowed byte orderings.</p>
<ul>
<li><a href="endian/enum.AnyEndian.html" title="enum elf::endian::AnyEndian">AnyEndian</a>: Dynamically parsing either byte order at runtime based on the type of ELF object being parsed.</li>
<li><a href="endian/struct.BigEndian.html" title="struct elf::endian::BigEndian">BigEndian</a>/<a href="endian/struct.LittleEndian.html" title="struct elf::endian::LittleEndian">LittleEndian</a>: For tools that know they only want to parse a single given byte order known at compile time.</li>
<li><a href="endian/type.NativeEndian.html" title="type elf::endian::NativeEndian">NativeEndian</a>: For tools that know they want to parse the same byte order as the compilation target‚Äôs byte order.</li>
</ul>
<p>When the limited specifications are used, errors are properly returned when asked to parse an ELF file
with an unexpected byte ordering.</p>
<h4 id="-zero-alloc-parser-"><a href="#-zero-alloc-parser-">‚ú® Zero-alloc parser ‚ú®</a></h4>
<p>This crate implements parsing in a way that avoids heap allocations. ELF structures
are parsed and stored on the stack and provided by patterns such as lazily parsed iterators
that yield stack allocated rust types, or lazily parsing tables that only parse out a particular
entry on table.get(index). The structures are copy-converted as needed from the underlying file
data into Rust‚Äôs native struct representation.</p>
<h4 id="-fuzz-tested-"><a href="#-fuzz-tested-">‚ú® Fuzz Tested ‚ú®</a></h4>
<p>Various parts of the library are fuzz tested for panics and crashes (see <code>fuzz/</code>).</p>
<p>Memory safety is a core goal, as is providing a safe interface that errors on bad data
over crashing or panicking. Checked integer math is used where appropriate, and ParseErrors are
returned when bad or corrupted ELF structures are encountered.</p>
<h4 id="-uses-only-safe-interfaces-"><a href="#-uses-only-safe-interfaces-">‚ú® Uses only safe interfaces ‚ú®</a></h4>
<p>With memory safety a core goal, this crate contains zero unsafe code blocks
of its own and only uses safe interface methods from core and std, so you can
trust in rust‚Äôs memory safety guarantees without also having to trust this
library developer as having truly been ‚Äúright‚Äù in why some unsafe block was
safe. üíÉ</p>
<p>Note: I‚Äôd love to see this crate be enhanced further once rust provides safe transmutes.</p>
<p>See: <a href="https://github.com/rust-lang/project-safe-transmute">https://github.com/rust-lang/project-safe-transmute</a></p>
<h4 id="-some-zero-copy-interfaces-"><a href="#-some-zero-copy-interfaces-">‚ú® Some zero-copy interfaces ‚ú®</a></h4>
<p>The StringTable, for instance, yields <code>&amp;[u8]</code> and <code>&amp;str</code> backed by the raw string table bytes.</p>
<p>The <a href="struct.ElfBytes.html" title="struct elf::ElfBytes">ElfBytes</a> parser type also does not make raw copies of the underlying file data to back
the parser lazy parser interfaces <code>ParsingIterator</code> and <code>ParsingTable</code>. They merely wrap byte slices
internally, and yield rust repr values on demand, which does entail copying of the bytes into the
parsed rust-native format.</p>
<p>Depending on the use-case, it can be more efficient to restructure the raw ELF into different layouts
for more efficient interpretation, say, by re-indexing a flat table into a HashMap. <code>ParsingIterator</code>s
make that easy and rustily-intuitive.</p>
<p>The <code>ParsingIterator</code>s are also nice in that you can easily zip/enumerate/filter/collect them
how you wish. Do you know that you want to do multiple passes over pairs from different tables? Just
zip/collect them into another type so you only parse/endian-flip each entry once!</p>
<h4 id="-stream-based-lazy-io-interface-"><a href="#-stream-based-lazy-io-interface-">‚ú® Stream-based lazy i/o interface ‚ú®</a></h4>
<p>The [ElfStream] parser type takes a <code>std:: Read + Seek</code> (such as <code>std::fs::File</code>) where ranges of
file contents are read lazily on-demand based on what the user wants to parse.</p>
<p>This, alongside the bytes-oriented interface, allow you to decide which tradeoffs
you want to make. If you‚Äôre going to be working with the whole file contents,
then the byte slice approach is probably worthwhile to minimize i/o overhead by
streaming the whole file into memory at once. If you‚Äôre only going to be
inspecting part of the file, then the [ElfStream] approach would help avoid the
overhead of reading a bunch of unused file data just to parse out a few things, (like
grabbing the <code>.gnu.note.build-id</code>)</p>
<h4 id="-tiny-library-with-no-dependencies-and-fast-compilation-times-"><a href="#-tiny-library-with-no-dependencies-and-fast-compilation-times-">‚ú® Tiny library with no dependencies and fast compilation times ‚ú®</a></h4>
<p>Release-target compilation times on this developer‚Äôs 2021 m1 macbook are sub-second.</p>
<p>Example using <a href="struct.ElfBytes.html" title="struct elf::ElfBytes">ElfBytes</a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>elf::ElfBytes;
<span class="kw">use </span>elf::endian::AnyEndian;
<span class="kw">use </span>elf::hash::sysv_hash;
<span class="kw">use </span>elf::note::Note;
<span class="kw">use </span>elf::note::NoteGnuBuildId;
<span class="kw">use </span>elf::section::SectionHeader;

<span class="kw">let </span>path = std::path::PathBuf::from(<span class="string">&quot;sample-objects/symver.x86_64.so&quot;</span>);
<span class="kw">let </span>file_data = std::fs::read(path).expect(<span class="string">&quot;Could not read file.&quot;</span>);
<span class="kw">let </span>slice = file_data.as_slice();
<span class="kw">let </span>file = ElfBytes::&lt;AnyEndian&gt;::minimal_parse(slice).expect(<span class="string">&quot;Open test1&quot;</span>);

<span class="comment">// Get the ELF file&#39;s build-id
</span><span class="kw">let </span>abi_shdr: SectionHeader = file
    .section_header_by_name(<span class="string">&quot;.note.gnu.build-id&quot;</span>)
    .expect(<span class="string">&quot;section table should be parseable&quot;</span>)
    .expect(<span class="string">&quot;file should have a .note.ABI-tag section&quot;</span>);

<span class="kw">let </span>notes: Vec&lt;Note&gt; = file
    .section_data_as_notes(<span class="kw-2">&amp;</span>abi_shdr)
    .expect(<span class="string">&quot;Should be able to get note section data&quot;</span>)
    .collect();
<span class="macro">assert_eq!</span>(
    notes[<span class="number">0</span>],
    Note::GnuBuildId(NoteGnuBuildId(
        <span class="kw-2">&amp;</span>[<span class="number">140</span>, <span class="number">51</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">221</span>, <span class="number">90</span>, <span class="number">215</span>, <span class="number">131</span>, <span class="number">169</span>, <span class="number">13</span>,
          <span class="number">210</span>, <span class="number">183</span>, <span class="number">215</span>, <span class="number">77</span>, <span class="number">216</span>, <span class="number">175</span>, <span class="number">167</span>, <span class="number">110</span>, <span class="number">3</span>, <span class="number">209</span>]))
);

<span class="comment">// Find lazy-parsing types for the common ELF sections (we want .dynsym, .dynstr, .hash)
</span><span class="kw">let </span>common = file.find_common_data().expect(<span class="string">&quot;shdrs should parse&quot;</span>);
<span class="kw">let </span>(dynsyms, strtab) = (common.dynsyms.unwrap(), common.dynsyms_strs.unwrap());
<span class="kw">let </span>hash_table = common.sysv_hash.unwrap();

<span class="comment">// Use the hash table to find a given symbol in it.
</span><span class="kw">let </span>name = <span class="string">b&quot;memset&quot;</span>;
<span class="kw">let </span>(sym_idx, sym) = hash_table.find(name, <span class="kw-2">&amp;</span>dynsyms, <span class="kw-2">&amp;</span>strtab)
    .expect(<span class="string">&quot;hash table and symbols should parse&quot;</span>).unwrap();

<span class="comment">// Verify that we got the same symbol from the hash table we expected
</span><span class="macro">assert_eq!</span>(sym_idx, <span class="number">2</span>);
<span class="macro">assert_eq!</span>(strtab.get(sym.st_name <span class="kw">as </span>usize).unwrap(), <span class="string">&quot;memset&quot;</span>);
<span class="macro">assert_eq!</span>(sym, dynsyms.get(sym_idx).unwrap());</code></pre></div>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.ParseError"><code>pub use parse::<a class="enum" href="parse/enum.ParseError.html" title="enum elf::parse::ParseError">ParseError</a>;</code></div></li></ul><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="abi/index.html" title="mod elf::abi">abi</a></div><div class="desc docblock-short">Contains ELF constants defined in the ELF gABI and various extensions</div></li><li><div class="item-name"><a class="mod" href="compression/index.html" title="mod elf::compression">compression</a></div><div class="desc docblock-short">Parsing <a href="compression/struct.CompressionHeader.html" title="struct elf::compression::CompressionHeader">CompressionHeader</a> from compressed ELF sections</div></li><li><div class="item-name"><a class="mod" href="dynamic/index.html" title="mod elf::dynamic">dynamic</a></div><div class="desc docblock-short">Parsing <code>.dynamic</code> section or <a href="abi/constant.PT_DYNAMIC.html" title="constant elf::abi::PT_DYNAMIC">PT_DYNAMIC</a> segment contents</div></li><li><div class="item-name"><a class="mod" href="endian/index.html" title="mod elf::endian">endian</a></div><div class="desc docblock-short">An all-safe-code endian-aware integer parsing implementation via the
<a href="endian/trait.EndianParse.html" title="trait elf::endian::EndianParse">EndianParse</a> trait.</div></li><li><div class="item-name"><a class="mod" href="file/index.html" title="mod elf::file">file</a></div><div class="desc docblock-short">Parsing the ELF File Header</div></li><li><div class="item-name"><a class="mod" href="gnu_symver/index.html" title="mod elf::gnu_symver">gnu_symver</a></div><div class="desc docblock-short">Parsing GNU extension sections for dynamic symbol versioning <code>.gnu.version.*</code></div></li><li><div class="item-name"><a class="mod" href="hash/index.html" title="mod elf::hash">hash</a></div><div class="desc docblock-short">Parsing hash table sections for symbol tables: <code>.hash</code>, and <code>.gnu.hash</code></div></li><li><div class="item-name"><a class="mod" href="note/index.html" title="mod elf::note">note</a></div><div class="desc docblock-short">Parsing ELF notes: <code>.note.*</code>, <a href="abi/constant.SHT_NOTE.html" title="constant elf::abi::SHT_NOTE">SHT_NOTE</a>, <a href="abi/constant.PT_NOTE.html" title="constant elf::abi::PT_NOTE">PT_NOTE</a></div></li><li><div class="item-name"><a class="mod" href="parse/index.html" title="mod elf::parse">parse</a></div><div class="desc docblock-short">Utilities to drive safe and lazy parsing of ELF structures.</div></li><li><div class="item-name"><a class="mod" href="relocation/index.html" title="mod elf::relocation">relocation</a></div><div class="desc docblock-short">Parsing relocation sections: <code>.rel.*</code>, <code>.rela.*</code>, <a href="abi/constant.SHT_REL.html" title="constant elf::abi::SHT_REL">SHT_REL</a>, <a href="abi/constant.SHT_RELA.html" title="constant elf::abi::SHT_RELA">SHT_RELA</a></div></li><li><div class="item-name"><a class="mod" href="section/index.html" title="mod elf::section">section</a></div><div class="desc docblock-short">Parsing the Section Header table</div></li><li><div class="item-name"><a class="mod" href="segment/index.html" title="mod elf::segment">segment</a></div><div class="desc docblock-short">Parsing the Program Header table aka Segment table aka <code>Elf_Phdr</code></div></li><li><div class="item-name"><a class="mod" href="string_table/index.html" title="mod elf::string_table">string_table</a></div><div class="desc docblock-short">Interpreting string table sections: <code>.strtab</code>, <a href="abi/constant.SHT_STRTAB.html" title="constant elf::abi::SHT_STRTAB">SHT_STRTAB</a></div></li><li><div class="item-name"><a class="mod" href="symbol/index.html" title="mod elf::symbol">symbol</a></div><div class="desc docblock-short">Parsing symbol table sections: <code>.symtab</code>, <code>.dynsym</code></div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.CommonElfData.html" title="struct elf::CommonElfData">CommonElfData</a></div><div class="desc docblock-short">This struct collects the common sections found in ELF objects</div></li><li><div class="item-name"><a class="struct" href="struct.ElfBytes.html" title="struct elf::ElfBytes">ElfBytes</a></div><div class="desc docblock-short">This type encapsulates the bytes-oriented interface for parsing ELF objects from <code>&amp;[u8]</code>.</div></li></ul></section></div></main></body></html>