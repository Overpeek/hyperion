<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This type encapsulates the bytes-oriented interface for parsing ELF objects from `&amp;[u8]`."><title>ElfBytes in elf - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-9ee3a5e31a2afa3e.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="elf" data-themes="" data-resource-suffix="" data-rustdoc-version="1.75.0-nightly (aa1a71e9e 2023-10-26)" data-channel="nightly" data-search-js="search-8fbf244ebcf71464.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-5f34af1a0ee6bacd.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../elf/index.html">elf</a><span class="version">0.7.2</span></h2></div><h2 class="location"><a href="#">ElfBytes</a></h2><div class="sidebar-elems"><section><h3><a href="#fields">Fields</a></h3><ul class="block"><li><a href="#structfield.ehdr">ehdr</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block"><li><a href="#method.dynamic">dynamic</a></li><li><a href="#method.dynamic_symbol_table">dynamic_symbol_table</a></li><li><a href="#method.find_common_data">find_common_data</a></li><li><a href="#method.minimal_parse">minimal_parse</a></li><li><a href="#method.section_data">section_data</a></li><li><a href="#method.section_data_as_notes">section_data_as_notes</a></li><li><a href="#method.section_data_as_relas">section_data_as_relas</a></li><li><a href="#method.section_data_as_rels">section_data_as_rels</a></li><li><a href="#method.section_data_as_strtab">section_data_as_strtab</a></li><li><a href="#method.section_header_by_name">section_header_by_name</a></li><li><a href="#method.section_headers">section_headers</a></li><li><a href="#method.section_headers_with_strtab">section_headers_with_strtab</a></li><li><a href="#method.segment_data">segment_data</a></li><li><a href="#method.segment_data_as_notes">segment_data_as_notes</a></li><li><a href="#method.segments">segments</a></li><li><a href="#method.symbol_table">symbol_table</a></li><li><a href="#method.symbol_version_table">symbol_version_table</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block"><li><a href="#impl-RefUnwindSafe-for-ElfBytes%3C'data,+E%3E">RefUnwindSafe</a></li><li><a href="#impl-Send-for-ElfBytes%3C'data,+E%3E">Send</a></li><li><a href="#impl-Sync-for-ElfBytes%3C'data,+E%3E">Sync</a></li><li><a href="#impl-Unpin-for-ElfBytes%3C'data,+E%3E">Unpin</a></li><li><a href="#impl-UnwindSafe-for-ElfBytes%3C'data,+E%3E">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In crate elf</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="index.html">elf</a>::<wbr><a class="struct" href="#">ElfBytes</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/elf/elf_bytes.rs.html#64-69">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct ElfBytes&lt;'data, E: <a class="trait" href="endian/trait.EndianParse.html" title="trait elf::endian::EndianParse">EndianParse</a>&gt; {
    pub ehdr: <a class="struct" href="file/struct.FileHeader.html" title="struct elf::file::FileHeader">FileHeader</a>&lt;E&gt;,
    /* private fields */
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This type encapsulates the bytes-oriented interface for parsing ELF objects from <code>&amp;[u8]</code>.</p>
<p>This parser is no_std and zero-alloc, returning lazy-parsing interfaces wrapped around
subslices of the provided ELF bytes <code>&amp;[u8]</code>. The various ELF structures are
parsed on-demand into a native Rust representation.</p>
<p>Example usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>elf::abi::PT_LOAD;
<span class="kw">use </span>elf::endian::AnyEndian;
<span class="kw">use </span>elf::ElfBytes;
<span class="kw">use </span>elf::segment::ProgramHeader;

<span class="kw">let </span>path = std::path::PathBuf::from(<span class="string">&quot;sample-objects/symver.x86_64.so&quot;</span>);
<span class="kw">let </span>file_data = std::fs::read(path).unwrap();

<span class="kw">let </span>slice = file_data.as_slice();
<span class="kw">let </span>file = ElfBytes::&lt;AnyEndian&gt;::minimal_parse(slice).unwrap();

<span class="comment">// Get all the common ELF sections (if any). We have a lot of ELF work to do!
</span><span class="kw">let </span>common_sections = file.find_common_data().unwrap();
<span class="comment">// ... do some stuff with the symtab, dynsyms etc

// It can also yield iterators on which we can do normal iterator things, like filtering
// for all the segments of a specific type. Parsing is done on each iter.next() call, so
// if you end iteration early, it won&#39;t parse the rest of the table.
</span><span class="kw">let </span>first_load_phdr: <span class="prelude-ty">Option</span>&lt;ProgramHeader&gt; = file.segments().unwrap()
    .iter()
    .find(|phdr|{phdr.p_type == PT_LOAD});
<span class="macro">println!</span>(<span class="string">&quot;First load segment is at: {}&quot;</span>, first_load_phdr.unwrap().p_vaddr);

<span class="comment">// Or if you do things like this to get a vec of only the PT_LOAD segments.
</span><span class="kw">let </span>all_load_phdrs: Vec&lt;ProgramHeader&gt; = file.segments().unwrap()
    .iter()
    .filter(|phdr|{phdr.p_type == PT_LOAD})
    .collect();
<span class="macro">println!</span>(<span class="string">&quot;There are {} PT_LOAD segments&quot;</span>, all_load_phdrs.len());</code></pre></div>
</div></details><h2 id="fields" class="fields small-section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.ehdr" class="structfield small-section-header"><a href="#structfield.ehdr" class="anchor field">§</a><code>ehdr: <a class="struct" href="file/struct.FileHeader.html" title="struct elf::file::FileHeader">FileHeader</a>&lt;E&gt;</code></span><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-ElfBytes%3C'data,+E%3E" class="impl"><a class="src rightside" href="../src/elf/elf_bytes.rs.html#167-818">source</a><a href="#impl-ElfBytes%3C'data,+E%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'data, E: <a class="trait" href="endian/trait.EndianParse.html" title="trait elf::endian::EndianParse">EndianParse</a>&gt; <a class="struct" href="struct.ElfBytes.html" title="struct elf::ElfBytes">ElfBytes</a>&lt;'data, E&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.minimal_parse" class="method"><a class="src rightside" href="../src/elf/elf_bytes.rs.html#174-195">source</a><h4 class="code-header">pub fn <a href="#method.minimal_parse" class="fn">minimal_parse</a>(data: &amp;'data [<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, <a class="enum" href="parse/enum.ParseError.html" title="enum elf::parse::ParseError">ParseError</a>&gt;</h4></section></summary><div class="docblock"><p>Do the minimal parsing work to get an <a href="struct.ElfBytes.html" title="struct elf::ElfBytes">ElfBytes</a> handle from a byte slice containing an ELF object.</p>
<p>This parses the ELF <a href="file/struct.FileHeader.html" title="struct elf::file::FileHeader">FileHeader</a>, and locates (but does not parse) the
Section Header Table and Segment Table.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.segments" class="method"><a class="src rightside" href="../src/elf/elf_bytes.rs.html#201-203">source</a><h4 class="code-header">pub fn <a href="#method.segments" class="fn">segments</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="segment/type.SegmentTable.html" title="type elf::segment::SegmentTable">SegmentTable</a>&lt;'data, E&gt;&gt;</h4></section></summary><div class="docblock"><p>Get this Elf object’s zero-alloc lazy-parsing <a href="segment/type.SegmentTable.html" title="type elf::segment::SegmentTable">SegmentTable</a> (if any).</p>
<p>This table parses <a href="segment/struct.ProgramHeader.html" title="struct elf::segment::ProgramHeader">ProgramHeader</a>s on demand and does not make any internal heap allocations
when parsing.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.section_headers" class="method"><a class="src rightside" href="../src/elf/elf_bytes.rs.html#209-211">source</a><h4 class="code-header">pub fn <a href="#method.section_headers" class="fn">section_headers</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="section/type.SectionHeaderTable.html" title="type elf::section::SectionHeaderTable">SectionHeaderTable</a>&lt;'data, E&gt;&gt;</h4></section></summary><div class="docblock"><p>Get this Elf object’s zero-alloc lazy-parsing <a href="section/type.SectionHeaderTable.html" title="type elf::section::SectionHeaderTable">SectionHeaderTable</a> (if any).</p>
<p>This table parses <a href="section/struct.SectionHeader.html" title="struct elf::section::SectionHeader">SectionHeader</a>s on demand and does not make any internal heap allocations
when parsing.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.section_headers_with_strtab" class="method"><a class="src rightside" href="../src/elf/elf_bytes.rs.html#262-298">source</a><h4 class="code-header">pub fn <a href="#method.section_headers_with_strtab" class="fn">section_headers_with_strtab</a>(
    &amp;self
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;(<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="section/type.SectionHeaderTable.html" title="type elf::section::SectionHeaderTable">SectionHeaderTable</a>&lt;'data, E&gt;&gt;, <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="string_table/struct.StringTable.html" title="struct elf::string_table::StringTable">StringTable</a>&lt;'data&gt;&gt;), <a class="enum" href="parse/enum.ParseError.html" title="enum elf::parse::ParseError">ParseError</a>&gt;</h4></section></summary><div class="docblock"><p>Get this ELF object’s <a href="section/type.SectionHeaderTable.html" title="type elf::section::SectionHeaderTable">SectionHeaderTable</a> alongside its corresponding <a href="string_table/struct.StringTable.html" title="struct elf::string_table::StringTable">StringTable</a>.</p>
<p>This is useful if you want to know the string name of sections.</p>
<p>Example usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::HashMap;
<span class="kw">use </span>elf::endian::AnyEndian;
<span class="kw">use </span>elf::ElfBytes;
<span class="kw">use </span>elf::note::Note;
<span class="kw">use </span>elf::note::NoteGnuBuildId;
<span class="kw">use </span>elf::section::SectionHeader;

<span class="kw">let </span>path = std::path::PathBuf::from(<span class="string">&quot;sample-objects/symver.x86_64.so&quot;</span>);
<span class="kw">let </span>file_data = std::fs::read(path).unwrap();

<span class="kw">let </span>slice = file_data.as_slice();
<span class="kw">let </span>file = ElfBytes::&lt;AnyEndian&gt;::minimal_parse(slice).unwrap();

<span class="comment">// Get the section header table alongside its string table
</span><span class="kw">let </span>(shdrs_opt, strtab_opt) = file
    .section_headers_with_strtab()
    .expect(<span class="string">&quot;shdrs offsets should be valid&quot;</span>);
<span class="kw">let </span>(shdrs, strtab) = (
    shdrs_opt.expect(<span class="string">&quot;Should have shdrs&quot;</span>),
    strtab_opt.expect(<span class="string">&quot;Should have strtab&quot;</span>)
);

<span class="comment">// Parse the shdrs and collect them into a map keyed on their zero-copied name
</span><span class="kw">let </span>with_names: HashMap&lt;<span class="kw-2">&amp;</span>str, SectionHeader&gt; = shdrs
    .iter()
    .map(|shdr| {
        (
            strtab.get(shdr.sh_name <span class="kw">as </span>usize).expect(<span class="string">&quot;Failed to get section name&quot;</span>),
            shdr,
        )
    })
    .collect();

<span class="comment">// Get the zero-copy parsed type for the the build id note
</span><span class="kw">let </span>build_id_note_shdr: <span class="kw-2">&amp;</span>SectionHeader = with_names
    .get(<span class="string">&quot;.note.gnu.build-id&quot;</span>)
    .expect(<span class="string">&quot;Should have build id note section&quot;</span>);
<span class="kw">let </span>notes: Vec&lt;<span class="kw">_</span>&gt; = file
    .section_data_as_notes(build_id_note_shdr)
    .expect(<span class="string">&quot;Should be able to get note section data&quot;</span>)
    .collect();
<span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, notes[<span class="number">0</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.section_header_by_name" class="method"><a class="src rightside" href="../src/elf/elf_bytes.rs.html#333-351">source</a><h4 class="code-header">pub fn <a href="#method.section_header_by_name" class="fn">section_header_by_name</a>(
    &amp;self,
    name: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.str.html">str</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="section/struct.SectionHeader.html" title="struct elf::section::SectionHeader">SectionHeader</a>&gt;, <a class="enum" href="parse/enum.ParseError.html" title="enum elf::parse::ParseError">ParseError</a>&gt;</h4></section></summary><div class="docblock"><p>Parse section headers until one is found with the given name</p>
<p>Example to get the ELF file’s ABI-tag note</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>elf::ElfBytes;
<span class="kw">use </span>elf::endian::AnyEndian;
<span class="kw">use </span>elf::section::SectionHeader;
<span class="kw">use </span>elf::note::Note;
<span class="kw">use </span>elf::note::NoteGnuAbiTag;

<span class="kw">let </span>path = std::path::PathBuf::from(<span class="string">&quot;sample-objects/basic.x86_64&quot;</span>);
<span class="kw">let </span>file_data = std::fs::read(path).unwrap();
<span class="kw">let </span>slice = file_data.as_slice();
<span class="kw">let </span>file = ElfBytes::&lt;AnyEndian&gt;::minimal_parse(slice).unwrap();

<span class="kw">let </span>shdr: SectionHeader = file
    .section_header_by_name(<span class="string">&quot;.note.ABI-tag&quot;</span>)
    .expect(<span class="string">&quot;section table should be parseable&quot;</span>)
    .expect(<span class="string">&quot;file should have a .note.ABI-tag section&quot;</span>);

<span class="kw">let </span>notes: Vec&lt;<span class="kw">_</span>&gt; = file
    .section_data_as_notes(<span class="kw-2">&amp;</span>shdr)
    .expect(<span class="string">&quot;Should be able to get note section data&quot;</span>)
    .collect();
<span class="macro">assert_eq!</span>(
    notes[<span class="number">0</span>],
    Note::GnuAbiTag(NoteGnuAbiTag {
        os: <span class="number">0</span>,
        major: <span class="number">2</span>,
        minor: <span class="number">6</span>,
        subminor: <span class="number">32
    </span>}));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_common_data" class="method"><a class="src rightside" href="../src/elf/elf_bytes.rs.html#360-427">source</a><h4 class="code-header">pub fn <a href="#method.find_common_data" class="fn">find_common_data</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.CommonElfData.html" title="struct elf::CommonElfData">CommonElfData</a>&lt;'data, E&gt;, <a class="enum" href="parse/enum.ParseError.html" title="enum elf::parse::ParseError">ParseError</a>&gt;</h4></section></summary><div class="docblock"><p>Efficiently locate the set of common sections found in ELF files by doing a single iteration
over the SectionHeaders table.</p>
<p>This is useful for those who know they’re going to be accessing multiple common sections, like
symbol tables, string tables. Many of these can also be accessed by the more targeted
helpers like <a href="struct.ElfBytes.html#method.symbol_table" title="method elf::ElfBytes::symbol_table">ElfBytes::symbol_table</a> or <a href="struct.ElfBytes.html#method.dynamic" title="method elf::ElfBytes::dynamic">ElfBytes::dynamic</a>, though those each do their own
internal searches through the shdrs to find the section.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.section_data" class="method"><a class="src rightside" href="../src/elf/elf_bytes.rs.html#438-465">source</a><h4 class="code-header">pub fn <a href="#method.section_data" class="fn">section_data</a>(
    &amp;self,
    shdr: &amp;<a class="struct" href="section/struct.SectionHeader.html" title="struct elf::section::SectionHeader">SectionHeader</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;(&amp;'data [<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>], <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="compression/struct.CompressionHeader.html" title="struct elf::compression::CompressionHeader">CompressionHeader</a>&gt;), <a class="enum" href="parse/enum.ParseError.html" title="enum elf::parse::ParseError">ParseError</a>&gt;</h4></section></summary><div class="docblock"><p>Get the section data for a given <a href="section/struct.SectionHeader.html" title="struct elf::section::SectionHeader">SectionHeader</a>, alongside an optional compression context.</p>
<p>This library does not do any decompression for the user, but merely returns the raw compressed
section data if the section is compressed alongside its ELF compression structure describing the
compression algorithm used.</p>
<p>Users who wish to work with compressed sections must pick their compression library of choice
and do the decompression themselves. The only two options supported by the ELF spec for section
compression are: <a href="abi/constant.ELFCOMPRESS_ZLIB.html" title="constant elf::abi::ELFCOMPRESS_ZLIB">abi::ELFCOMPRESS_ZLIB</a> and <a href="abi/constant.ELFCOMPRESS_ZSTD.html" title="constant elf::abi::ELFCOMPRESS_ZSTD">abi::ELFCOMPRESS_ZSTD</a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.section_data_as_strtab" class="method"><a class="src rightside" href="../src/elf/elf_bytes.rs.html#470-483">source</a><h4 class="code-header">pub fn <a href="#method.section_data_as_strtab" class="fn">section_data_as_strtab</a>(
    &amp;self,
    shdr: &amp;<a class="struct" href="section/struct.SectionHeader.html" title="struct elf::section::SectionHeader">SectionHeader</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="string_table/struct.StringTable.html" title="struct elf::string_table::StringTable">StringTable</a>&lt;'data&gt;, <a class="enum" href="parse/enum.ParseError.html" title="enum elf::parse::ParseError">ParseError</a>&gt;</h4></section></summary><div class="docblock"><p>Get the section data for a given <a href="section/struct.SectionHeader.html" title="struct elf::section::SectionHeader">SectionHeader</a>, and interpret it as a <a href="string_table/struct.StringTable.html" title="struct elf::string_table::StringTable">StringTable</a></p>
<p>Returns a ParseError if the section is not of type <a href="abi/constant.SHT_STRTAB.html" title="constant elf::abi::SHT_STRTAB">abi::SHT_STRTAB</a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.section_data_as_rels" class="method"><a class="src rightside" href="../src/elf/elf_bytes.rs.html#489-502">source</a><h4 class="code-header">pub fn <a href="#method.section_data_as_rels" class="fn">section_data_as_rels</a>(
    &amp;self,
    shdr: &amp;<a class="struct" href="section/struct.SectionHeader.html" title="struct elf::section::SectionHeader">SectionHeader</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="type" href="relocation/type.RelIterator.html" title="type elf::relocation::RelIterator">RelIterator</a>&lt;'data, E&gt;, <a class="enum" href="parse/enum.ParseError.html" title="enum elf::parse::ParseError">ParseError</a>&gt;</h4></section></summary><div class="docblock"><p>Get the section data for a given <a href="section/struct.SectionHeader.html" title="struct elf::section::SectionHeader">SectionHeader</a>, and interpret it as an
iterator over no-addend relocations <a href="relocation/struct.Rel.html" title="struct elf::relocation::Rel">Rel</a></p>
<p>Returns a ParseError if the section is not of type <a href="abi/constant.SHT_REL.html" title="constant elf::abi::SHT_REL">abi::SHT_REL</a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.section_data_as_relas" class="method"><a class="src rightside" href="../src/elf/elf_bytes.rs.html#508-525">source</a><h4 class="code-header">pub fn <a href="#method.section_data_as_relas" class="fn">section_data_as_relas</a>(
    &amp;self,
    shdr: &amp;<a class="struct" href="section/struct.SectionHeader.html" title="struct elf::section::SectionHeader">SectionHeader</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="type" href="relocation/type.RelaIterator.html" title="type elf::relocation::RelaIterator">RelaIterator</a>&lt;'data, E&gt;, <a class="enum" href="parse/enum.ParseError.html" title="enum elf::parse::ParseError">ParseError</a>&gt;</h4></section></summary><div class="docblock"><p>Get the section data for a given <a href="section/struct.SectionHeader.html" title="struct elf::section::SectionHeader">SectionHeader</a>, and interpret it as an
iterator over relocations with addends <a href="relocation/struct.Rela.html" title="struct elf::relocation::Rela">Rela</a></p>
<p>Returns a ParseError if the section is not of type <a href="abi/constant.SHT_RELA.html" title="constant elf::abi::SHT_RELA">abi::SHT_RELA</a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.section_data_as_notes" class="method"><a class="src rightside" href="../src/elf/elf_bytes.rs.html#531-549">source</a><h4 class="code-header">pub fn <a href="#method.section_data_as_notes" class="fn">section_data_as_notes</a>(
    &amp;self,
    shdr: &amp;<a class="struct" href="section/struct.SectionHeader.html" title="struct elf::section::SectionHeader">SectionHeader</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="note/struct.NoteIterator.html" title="struct elf::note::NoteIterator">NoteIterator</a>&lt;'data, E&gt;, <a class="enum" href="parse/enum.ParseError.html" title="enum elf::parse::ParseError">ParseError</a>&gt;</h4></section></summary><div class="docblock"><p>Get the section data for a given <a href="section/struct.SectionHeader.html" title="struct elf::section::SectionHeader">SectionHeader</a>, and interpret it as an
iterator over <a href="note/enum.Note.html" title="enum elf::note::Note">Note</a>s</p>
<p>Returns a ParseError if the section is not of type <a href="abi/constant.SHT_NOTE.html" title="constant elf::abi::SHT_NOTE">abi::SHT_NOTE</a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.segment_data" class="method"><a class="src rightside" href="../src/elf/elf_bytes.rs.html#577-580">source</a><h4 class="code-header">pub fn <a href="#method.segment_data" class="fn">segment_data</a>(
    &amp;self,
    phdr: &amp;<a class="struct" href="segment/struct.ProgramHeader.html" title="struct elf::segment::ProgramHeader">ProgramHeader</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;'data [<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>], <a class="enum" href="parse/enum.ParseError.html" title="enum elf::parse::ParseError">ParseError</a>&gt;</h4></section></summary><div class="docblock"><p>Get the segment’s file data for a given segment/<a href="segment/struct.ProgramHeader.html" title="struct elf::segment::ProgramHeader">ProgramHeader</a>.</p>
<p>This is the segment’s data as found in the file.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.segment_data_as_notes" class="method"><a class="src rightside" href="../src/elf/elf_bytes.rs.html#586-604">source</a><h4 class="code-header">pub fn <a href="#method.segment_data_as_notes" class="fn">segment_data_as_notes</a>(
    &amp;self,
    phdr: &amp;<a class="struct" href="segment/struct.ProgramHeader.html" title="struct elf::segment::ProgramHeader">ProgramHeader</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="note/struct.NoteIterator.html" title="struct elf::note::NoteIterator">NoteIterator</a>&lt;'data, E&gt;, <a class="enum" href="parse/enum.ParseError.html" title="enum elf::parse::ParseError">ParseError</a>&gt;</h4></section></summary><div class="docblock"><p>Get the segment’s file data for a given <a href="segment/struct.ProgramHeader.html" title="struct elf::segment::ProgramHeader">ProgramHeader</a>, and interpret it as an
iterator over <a href="note/enum.Note.html" title="enum elf::note::Note">Note</a>s</p>
<p>Returns a ParseError if the section is not of type <a href="abi/constant.PT_NOTE.html" title="constant elf::abi::PT_NOTE">abi::PT_NOTE</a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.dynamic" class="method"><a class="src rightside" href="../src/elf/elf_bytes.rs.html#607-627">source</a><h4 class="code-header">pub fn <a href="#method.dynamic" class="fn">dynamic</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="dynamic/type.DynamicTable.html" title="type elf::dynamic::DynamicTable">DynamicTable</a>&lt;'data, E&gt;&gt;, <a class="enum" href="parse/enum.ParseError.html" title="enum elf::parse::ParseError">ParseError</a>&gt;</h4></section></summary><div class="docblock"><p>Get the .dynamic section or <a href="abi/constant.PT_DYNAMIC.html" title="constant elf::abi::PT_DYNAMIC">abi::PT_DYNAMIC</a> segment contents.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.symbol_table" class="method"><a class="src rightside" href="../src/elf/elf_bytes.rs.html#655-678">source</a><h4 class="code-header">pub fn <a href="#method.symbol_table" class="fn">symbol_table</a>(
    &amp;self
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="type" href="symbol/type.SymbolTable.html" title="type elf::symbol::SymbolTable">SymbolTable</a>&lt;'data, E&gt;, <a class="struct" href="string_table/struct.StringTable.html" title="struct elf::string_table::StringTable">StringTable</a>&lt;'data&gt;)&gt;, <a class="enum" href="parse/enum.ParseError.html" title="enum elf::parse::ParseError">ParseError</a>&gt;</h4></section></summary><div class="docblock"><p>Get the ELF file’s <code>.symtab</code> and associated strtab (if any)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.dynamic_symbol_table" class="method"><a class="src rightside" href="../src/elf/elf_bytes.rs.html#681-704">source</a><h4 class="code-header">pub fn <a href="#method.dynamic_symbol_table" class="fn">dynamic_symbol_table</a>(
    &amp;self
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="type" href="symbol/type.SymbolTable.html" title="type elf::symbol::SymbolTable">SymbolTable</a>&lt;'data, E&gt;, <a class="struct" href="string_table/struct.StringTable.html" title="struct elf::string_table::StringTable">StringTable</a>&lt;'data&gt;)&gt;, <a class="enum" href="parse/enum.ParseError.html" title="enum elf::parse::ParseError">ParseError</a>&gt;</h4></section></summary><div class="docblock"><p>Get the ELF file’s <code>.dynsym</code> and associated strtab (if any)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.symbol_version_table" class="method"><a class="src rightside" href="../src/elf/elf_bytes.rs.html#713-817">source</a><h4 class="code-header">pub fn <a href="#method.symbol_version_table" class="fn">symbol_version_table</a>(
    &amp;self
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="gnu_symver/struct.SymbolVersionTable.html" title="struct elf::gnu_symver::SymbolVersionTable">SymbolVersionTable</a>&lt;'data, E&gt;&gt;, <a class="enum" href="parse/enum.ParseError.html" title="enum elf::parse::ParseError">ParseError</a>&gt;</h4></section></summary><div class="docblock"><p>Locate the section data for the various GNU Symbol Versioning sections (if any)
and return them in a <a href="gnu_symver/struct.SymbolVersionTable.html" title="struct elf::gnu_symver::SymbolVersionTable">SymbolVersionTable</a> that which can interpret them in-place to
yield <a href="gnu_symver/struct.SymbolRequirement.html" title="struct elf::gnu_symver::SymbolRequirement">SymbolRequirement</a>s
and <a href="gnu_symver/struct.SymbolDefinition.html" title="struct elf::gnu_symver::SymbolDefinition">SymbolDefinition</a>s</p>
<p>This is a GNU extension and not all objects use symbol versioning.
Returns an empty Option if the object does not use symbol versioning.</p>
</div></details></div></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-ElfBytes%3C'data,+E%3E" class="impl"><a href="#impl-RefUnwindSafe-for-ElfBytes%3C'data,+E%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'data, E&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.ElfBytes.html" title="struct elf::ElfBytes">ElfBytes</a>&lt;'data, E&gt;<span class="where fmt-newline">where
    E: <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</span></h3></section><section id="impl-Send-for-ElfBytes%3C'data,+E%3E" class="impl"><a href="#impl-Send-for-ElfBytes%3C'data,+E%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'data, E&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.ElfBytes.html" title="struct elf::ElfBytes">ElfBytes</a>&lt;'data, E&gt;<span class="where fmt-newline">where
    E: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,</span></h3></section><section id="impl-Sync-for-ElfBytes%3C'data,+E%3E" class="impl"><a href="#impl-Sync-for-ElfBytes%3C'data,+E%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'data, E&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.ElfBytes.html" title="struct elf::ElfBytes">ElfBytes</a>&lt;'data, E&gt;<span class="where fmt-newline">where
    E: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,</span></h3></section><section id="impl-Unpin-for-ElfBytes%3C'data,+E%3E" class="impl"><a href="#impl-Unpin-for-ElfBytes%3C'data,+E%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'data, E&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.ElfBytes.html" title="struct elf::ElfBytes">ElfBytes</a>&lt;'data, E&gt;<span class="where fmt-newline">where
    E: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</span></h3></section><section id="impl-UnwindSafe-for-ElfBytes%3C'data,+E%3E" class="impl"><a href="#impl-UnwindSafe-for-ElfBytes%3C'data,+E%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'data, E&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.ElfBytes.html" title="struct elf::ElfBytes">ElfBytes</a>&lt;'data, E&gt;<span class="where fmt-newline">where
    E: <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,</span></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#135">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#136">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#763">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#766">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#747-749">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#756">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#803-805">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#810">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#788-790">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#795">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>